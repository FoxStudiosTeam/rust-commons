// THIS FILE IS GENERATED, NOT FOR MANUAL EDIT
use sqlx::{Executor, FromRow};
use sqlx::query::QueryAs;
use orm::prelude::*;
use sqlx::Pool;

#[derive(Clone, Debug, FromRow)]
pub struct {{snakeToPascal table.name}} {
    {{#each table.fields}}
    pub {{name}}: {{#if nullable}}Option<{{type_str}}>{{else}}{{type_str}}{{/if}},
    {{/each}}
}

impl {{snakeToPascal table.name}} {
    pub fn into_active(self) -> Active{{snakeToPascal table.name}} {
        Active{{snakeToPascal table.name}} {
            {{#each table.fields}}
            {{name}}: Set(self.{{name}}),
            {{/each}}
        }
    }
}

#[derive(Clone,Debug, Default, FromRow)]
pub struct Active{{snakeToPascal table.name}} {
    {{#each table.fields}}
    pub {{name}}: Optional<{{#if nullable}}Option<{{type_str}}>{{else}}{{type_str}}{{/if}}>,
    {{/each}}
}

impl Active{{snakeToPascal table.name}} {
    pub fn into_{{table.name}}(self) -> Option<{{snakeToPascal table.name}}> {
        Some({{snakeToPascal table.name}} {
            {{#each table.fields}}
            {{name}}: self.{{name}}.into_option()?,
            {{/each}}
        })
    }
}

pub trait Orm{{snakeToPascal table.name}}<DB: OrmDB> {
    fn {{table.name}}<'e>(&'e self) -> DBSelector<'e, DB, Pool<DB>, Active{{snakeToPascal table.name}}>
    where 
        &'e Pool<DB>: Executor<'e, Database = DB>;
}

pub trait OrmTX{{snakeToPascal table.name}}<'c, DB: OrmDB> {
    fn {{table.name}}(&'c mut self) -> TxSelector<'c, DB, Active{{snakeToPascal table.name}}>;
}

impl TableSelector for Active{{snakeToPascal table.name}} {
    const TABLE_NAME: &'static str = "{{table.name}}";
    const TABLE_SCHEMA: &'static str = "{{table.schema}}";
    type TypePK = {{#each table.fields}}{{#if is_primary}}{{type_str}}{{/if}}{{/each}};
    fn pk_column() -> &'static str {
        {{#each table.fields}}
        {{#if is_primary}}
        "{{name}}"
        {{/if}}
        {{/each}}
    }
    fn is_field_set(&self, field_name: &str) -> bool {
        match field_name {
            {{#each table.fields}}
            "{{name}}" => self.{{name}}.is_set(),
            {{/each}}
            _ => unreachable!("Unknown field name: {}", field_name),
        }
    }
    fn columns() -> &'static [ColumnDef] {
        &[
            {{#each table.fields}}
            ColumnDef{
                name: "{{name}}",
                nullable: {{nullable}},
                default: {{#if default}}Some("{{default}}"){{else}}None{{/if}},
                is_unique: {{is_unique}},
                is_primary: {{is_primary}},
            },
            {{/each}}
        ]
    }
}
{{#each dbs}}

#[cfg(feature="{{feature}}")]
impl Orm{{snakeToPascal ../table.name}}<{{db}}> for Orm<Pool<{{db}}>>
{
    fn {{../table.name}}<'e>(&'e self) -> DBSelector<'e, {{db}}, Pool<{{db}}>, Active{{snakeToPascal ../table.name}}>
    where 
        &'e Pool<{{db}}>: Executor<'e, Database = {{db}}>
    {
        DBSelector::new(&self.get_executor())
    }
}

#[cfg(feature="{{feature}}")]
impl<'c> OrmTX{{snakeToPascal ../table.name}}<'c, {{db}}> for OrmTX<{{db}}>
{
    fn {{../table.name}}(&'c mut self) -> TxSelector<'c, {{db}}, Active{{snakeToPascal ../table.name}}>
    {
        TxSelector::new(self.get_inner())
    }
}

#[cfg(feature="{{feature}}")]
impl ModelOps<{{db}}> for Active{{snakeToPascal ../table.name}} 
{
    type NonActive = {{snakeToPascal ../table.name}};
    async fn save<'e,E>(self, exec: E, mode: SaveMode) -> Result<Option<Self::NonActive>, anyhow::Error> 
    where E: Executor<'e, Database = {{db}}> ,for<'q> <{{db}} as sqlx::Database>::Arguments<'q> :Default+sqlx::IntoArguments<'q, {{db}}>  {
        match mode {
            Insert => self.insert(exec).await,
            Update => self.update(exec).await,
            Upsert => self.upsert(exec).await
        }
    }

        fn complete_query<'s, 'q, T>(&'s self, mut q: QueryAs<'q, {{db}}, T, <{{db}} as sqlx::Database>::Arguments<'q>>)
    -> sqlx::query::QueryAs<'q,{{db}},T, <{{db}} as sqlx::Database>::Arguments<'q> > where 's: 'q {
        {{#each ../table.fields}}
        if let Set(v) = &self.{{name}} {tracing::debug!("Binded {{name}}"); q = q.bind(v);}
        {{/each}}
        q
    }
    
    async fn insert<'e,E>(self, exec: E) -> Result<Option<Self::NonActive>, anyhow::Error> 
    where E: Executor<'e, Database = {{db}}> ,for<'q> <{{db}} as sqlx::Database>::Arguments<'q> :Default+sqlx::IntoArguments<'q, {{db}}>  {
        let sql = <Self as SqlBuilder<{{db}}>>::insert_for(&self)?;
        tracing::debug!("Insert sql: {}", sql);
        let incomplete = sqlx::query_as::<_, Self::NonActive>(&sql);
        let complete = self.complete_query(incomplete);
        let r = complete
            .fetch_one(exec)
            .await;
        match r {
            Ok(v) => Ok(Some(v)),
            Err(e) if e.as_database_error()
                .and_then(|d| d.code()) == Some(std::borrow::Cow::Borrowed("23505")) => {
                // 23505 = unique_violation
                Ok(None)
            }
            Err(e) => Err(e.into())
        }
    }
    async fn upsert<'e,E>(self, exec: E) -> Result<Option<Self::NonActive>, anyhow::Error> 
    where E: Executor<'e, Database = {{db}}> ,for<'q> <{{db}} as sqlx::Database>::Arguments<'q> :Default+sqlx::IntoArguments<'q, {{db}}>  {
        let sql = <Self as SqlBuilder<{{db}}>>::upsert_for(&self)?;
        tracing::debug!("Upsert sql: {}", sql);
        let incomplete = sqlx::query_as::<_, Self::NonActive>(&sql);
        let complete = self.complete_query(incomplete);
        let r = complete
            .fetch_optional(exec)
            .await?;
        Ok(r)
    }
    async fn update<'e,E>(self, exec: E) -> Result<Option<Self::NonActive>, anyhow::Error> 
    where E: Executor<'e, Database = {{db}}> ,for<'q> <{{db}} as sqlx::Database>::Arguments<'q> :Default+sqlx::IntoArguments<'q, {{db}}>  {
        let sql = <Self as SqlBuilder<{{db}}>>::update_for(&self)?;
        tracing::debug!("Update sql: {}", sql);
        let incomplete = sqlx::query_as::<_, Self::NonActive>(&sql);
        let complete = self.complete_query(incomplete);
        let r = complete
            .fetch_optional(exec)
            .await?;
        Ok(r)
    }

    async fn select_by_pk<'e, E>(pk: &Self::TypePK, exec: E) -> Result<Option<Self::NonActive>, anyhow::Error>
    where
        E: Executor<'e, Database = {{db}}>
    {
        let sql = <Self as SqlBuilder<{{db}}>>::select_by_pk();
        let r = sqlx::query_as::<_, Self::NonActive>(&sql)
            .bind(pk)
            .fetch_optional(exec)
            .await?;
        Ok(r)
    }

    async fn delete_by_pk<'e, E>(pk: &Self::TypePK, exec: E) -> Result<Option<Self::NonActive>, anyhow::Error>
    where
        E: Executor<'e, Database = {{db}}>
    {
        let sql = <Self as SqlBuilder<{{db}}>>::delete_by_pk();
        let r = sqlx::query_as::<_, Self::NonActive>(&sql)
            .bind(pk)
            .fetch_optional(exec)
            .await?;
        Ok(r)
    }
    
    async fn count<'e, E>(exec: E) -> Result<i64, anyhow::Error>
    where
        E: Executor<'e, Database = {{db}}> {
        use sqlx::Row;
        let sql = <Self as SqlBuilder<{{db}}>>::count();
        let rec = sqlx::query(&sql)
            .fetch_one(exec)
            .await?.get(0);
        Ok(rec)
    }
}
{{/each}}